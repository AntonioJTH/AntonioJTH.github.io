<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Partitions · Convex Hulls · Intersection · Move-1 Graph</title>
  <style>
    :root { --bg:#0b0c10; --panel:#11131a; --text:#e8e8ea; --muted:#a6a7ad; --border:#2a2d3a; }
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      background:var(--bg); color:var(--text); }
    header { padding:14px 16px; border-bottom:1px solid var(--border); background:linear-gradient(180deg,#0f1118,#0b0c10); }
    header h1 { margin:0; font-size:16px; font-weight:650; letter-spacing:.2px; }
    
    /* Layout principal: gráficas grandes, notas pequeñas */
    .wrap { 
      display: grid;
      grid-template-columns: 4fr 1fr;
      gap: 14px;
      padding: 14px;
      height: calc(100vh - 60px);
    }
    
    .main-content {
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 14px;
      height: 100%;
    }
    
    .card { background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    label { font-size:12px; color:var(--muted); }
    select, button, input[type="range"] {
      background:#0d0f15; color:var(--text); border:1px solid var(--border);
      border-radius:10px; padding:8px 10px; font-size:13px;
    }
    button { cursor:pointer; }
    button:hover { filter:brightness(1.1); }
    button:active { transform: translateY(1px); }
    .btns { display:flex; gap:10px; flex-wrap:wrap; }
    
    /* TRES GRÁFICAS CUADRADAS EN GRID 2x2 */
    .graphs-main-container {
      display: grid;
      grid-template-columns: 1fr 1fr; /* Dos columnas */
      grid-template-rows: 1fr auto; /* Dos filas */
      gap: 14px;
      height: calc(70vh - 28px); /* Ajusta según necesites */
    }
    
    /* Primeras dos gráficas (arriba) */
    .graph-card-large {
      grid-row: 1;
      padding: 10px;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
    }
    
    /* Tercera gráfica (abajo, ocupando ambas columnas) */
    .graph-card-bottom {
      grid-column: 1 
      grid-row: 2;
      padding: 10px;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
    }
    
    /* Todas las gráficas cuadradas */
    .graph-card-large canvas,
    .graph-card-bottom canvas {
      flex: 1;
      width: 100%;
      aspect-ratio: 1 / 1; /* Hace que sean cuadradas */
      min-height: 300px;
      background:#0b0c10;
      border:1px solid var(--border);
      border-radius:12px;
    }
    
    /* Asegurar que los canvas mantengan proporción cuadrada */
    #canvasPts, #canvasGraph, #canvasHull {
      aspect-ratio: 1 / 1;
    }
    
    /* Ajuste específico para la tercera gráfica */
    .graph-card-bottom .row {
      margin-bottom: 8px;
    }
    
    /* Panel de KPI compacto */
    .kpi-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
    }
    
    .kpi-row {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 14px;
      margin-top: 14px;
    }
    
    .small { font-size:12px; color:var(--muted); }
    .stat { font-size:13px; }
    .kpi { display:flex; gap:10px; flex-wrap:wrap; }
    .pill { padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:#0d0f15; font-size:12px; color:var(--muted); }
    
    /* Panel de notas pequeño */
    .notes-panel {
      padding: 12px;
      max-height: 100%;
      overflow-y: auto;
    }
    
    .notes-panel .stat {
      margin-bottom: 10px;
    }
    
    .notes-panel .small {
      line-height: 1.4;
      font-size: 11px;
    }

    /* NUEVO: Panel de estadísticas de grafo */
    .stats-panel {
      grid-column: 2; /* Columna derecha */
      grid-row: 2; /* Fila inferior */
      padding: 10px;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .stats-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 10px;
    }

    .stats-buttons button {
      width: 100%;
      font-size: 11px;
      padding: 6px 8px;
    }

    .stats-output {
      flex: 1;
      background: #0d0f15;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      font-size: 11px;
      color: var(--muted);
      line-height: 1.4;
      overflow-y: auto;
      max-height: 200px;
    }

    .stats-output b {
      color: var(--text);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 8px;
    }

    .stat-item {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px;
      font-size: 10px;
    }

    .stat-value {
      color: var(--text);
      font-weight: bold;
      font-size: 12px;
      margin-top: 2px;
    }
  </style>

  <!-- jsPDF (PDF export) -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
</head>
<body>
<header>
  <h1>Tverberg Partition Graphs</h1>
</header>

<div class="wrap">

  <!-- CONTENIDO PRINCIPAL -->
  <div class="main-content">
    <!-- Controles -->
    <div class="card">
      <div class="row">
        <div class="row" style="gap:8px;">
          <label for="nPts">Number of points</label>
          <select id="nPts"></select>
        </div>

        <div class="row" style="gap:8px;">
          <label for="kParts">Number of parts (k)</label>
          <select id="kParts"></select>
        </div>

        <div class="row" style="gap:8px;">
          <label for="range">Plot range</label>
          <input id="range" type="range" min="2" max="10" step="1" value="4" />
          <span class="small" id="rangeVal">4</span>
        </div>

        <div class="btns" style="margin-left:auto;">
          <button id="btnCoords">Export coordinates (.txt)</button>
          <button id="btnPDF">Save plots (PDF, 4 per page)</button>
        </div>
      </div>
    </div>

    <!-- TRES GRÁFICAS CUADRADAS -->
    <div class="graphs-main-container">
      <!-- Gráfica 1: Points -->
      <div class="card graph-card-large">
        <div class="row" style="justify-content:space-between; margin-bottom:8px;">
          <div class="stat"><b>Points</b> </div>
          <div class="small">Drag a point to recompute everything</div>
        </div>
        <canvas id="canvasPts" width="600" height="600"></canvas>
      </div>

      <!-- Gráfica 2: Partition Graph -->
      <div class="card graph-card-large">
        <div class="row" style="justify-content:space-between; margin-bottom:8px;">
          <div class="stat"><b>Tverberg partition graph</b> </div>
          <div class="small">nodes = intersecting partitions</div>
        </div>
        <canvas id="canvasGraph" width="600" height="600"></canvas>
      </div>

      <!-- Gráfica 3: Convex Hulls (cuadrada, ocupa ancho completo) -->
      <div class="card graph-card-bottom">
        <div class="row" style="justify-content:space-between; margin-bottom:8px;">
          <div class="stat"><b>Convex hulls</b> of a selected partition</div>
          <div class="row" style="gap:8px;">
            <label for="selPart">Partition #</label>
            <select id="selPart"></select>
          </div>
        </div>
        <canvas id="canvasHull" width="600" height="600"></canvas>
        <div class="small" style="margin-top:8px;">
          The selector only lists partitions whose convex hulls have a <b>non-empty intersection</b>.
          <span style="float:right;">Edge exists if two partitions differ by moving exactly <b>one element</b> from one part to another (k fixed).</span>
        </div>
      </div>

      <!-- NUEVO: Panel de estadísticas de grafo -->
      <div class="card stats-panel">
        <div class="row" style="justify-content:space-between; margin-bottom:8px;">
          <div class="stat"><b>Graph Statistics</b></div>
          <div class="small">Plot 2 analysis</div>
        </div>
        
        <div class="stats-buttons">
          <button id="btnStatsBasic">Basic Stats</button>
          <button id="btnStatsDegrees">Degrees</button>
          <button id="btnStatsConnectivity">Connectivity</button>
          <button id="btnStatsClique">Clique Number</button>
        </div>
        
        <div class="stats-output" id="statsOutput">
          Click a button to display graph statistics.
        </div>

        <div class="stats-grid" id="statsGrid">
          <!-- Las estadísticas se llenarán automáticamente -->
        </div>
      </div>
    </div>
  </div>

<!-- PANEL DE NOTAS (más pequeño) -->
<div class="card notes-panel">
  <div class="stat"><b>Visualization of Tverberg Partition Graphs</b></div>
  <div class="small" style="margin-top:8px; line-height:1.4;">
    <b>What this tool shows:</b><br/>
    Given a set of points (first plot), this visualization generates the graph of Tverberg partitions, 
    as described in the paper <i>"Tverberg Partition Graphs"</i> 
    (https://epubs.siam.org/doi/10.1137/23M1610938).<br/><br/>
    
    <b>How it works:</b><br/>
    1. <b>First plot:</b> Shows the initial set of points. Drag points to modify configurations.<br/>
    2. <b>Second plot:</b> Displays the Tverberg partition graph.<br/>
    3. <b>Third plot:</b> Shows convex hulls of each part for a selected Tverberg partition.<br/><br/>
    
    <b>Tverberg partition:</b><br/>
    A partition of points into k parts such that the convex hulls of all parts have non-empty intersection.<br/><br/>
    
    <b>Controls:</b><br/>
    • <b>Number of points</b>: Total points to partition (n ≤ 9)<br/>
    • <b>Number of parts (k)</b>: Partition size (k ≤ 5)<br/>
    • <b>RANGE</b>: Coordinate bounds (±range)<br/>
    • <b>Partition #</b>: Select specific Tverberg partition to visualize<br/><br/>
    
    <b>Interaction:</b><br/>
    • Drag points in first plot to update all partitions<br/>
    • Drag nodes in graph view to rearrange layout<br/>
    • Use selector to view different partitions' convex hulls<br/><br/>
    
    <b>Technical details:</b><br/>
    • Self-contained HTML file (no server needed)<br/>
    • Intersection test uses Helly-based check + candidate points<br/>
    • Edge = partitions differ by moving exactly one element between parts<br/>
    • PDF export: 4 hull plots per page<br/>
    • Text export: Coordinates of all Tverberg partitions
  </div>
</div>

 <!-- Botón centrado, fuera del layout de canvases -->
    <div style="margin-top: 40px; text-align: center;">
        <button class="back-button"
            onclick="window.location.href='https://antoniojth.github.io/media.html'">
            ⬅ Back to Media & More
        </button>
    </div>


  
</div>

<script>
/* ===================== UTILITIES ===================== */

const EPS = 1e-9;
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const dist2 = (a,b)=>{ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; };

/* ===================== GEOMETRY: CONVEX HULL (Monotonic Chain) ===================== */

function cross(o,a,b){
  return (a.x-o.x)*(b.y-o.y) - (a.y-o.y)*(b.x-o.x);
}

function convexHull(points){
  const pts = points.slice().sort((p,q)=> p.x===q.x ? p.y-q.y : p.x-q.x);
  if (pts.length <= 1) return pts.slice();

  const lower = [];
  for (const p of pts){
    while (lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
    lower.push(p);
  }
  const upper = [];
  for (let i=pts.length-1;i>=0;i--){
    const p = pts[i];
    while (upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
    upper.push(p);
  }
  upper.pop(); lower.pop();
  return lower.concat(upper);
}

/* ===================== REGION REPRESENTATION ===================== */

function dot(a,b){ return a.x*b.x + a.y*b.y; }
function sub(a,b){ return {x:a.x-b.x, y:a.y-b.y}; }

function pointOnSegment(p,a,b){
  const ap=sub(p,a), ab=sub(b,a);
  const crossv = ap.x*ab.y - ap.y*ab.x;
  if (Math.abs(crossv) > 1e-7) return false;
  const t = dot(ap,ab) / (dot(ab,ab)+EPS);
  return t > -1e-7 && t < 1+1e-7;
}

function pointInConvexPolygon(p, poly){
  let sign = 0;
  for (let i=0;i<poly.length;i++){
    const a=poly[i], b=poly[(i+1)%poly.length];
    const c = cross(a,b,p);
    if (Math.abs(c) < 1e-9) continue;
    if (sign===0) sign = Math.sign(c);
    else if (Math.sign(c) !== sign) return false;
  }
  return true;
}

function pointInRegion(p, region){
  if (region.type==='point'){
    const q=region.pts[0];
    return (Math.abs(p.x-q.x)<1e-7 && Math.abs(p.y-q.y)<1e-7);
  }
  if (region.type==='segment'){
    return pointOnSegment(p, region.pts[0], region.pts[1]);
  }
  return pointInConvexPolygon(p, region.pts);
}

function segIntersect(a,b,c,d){
  function orient(p,q,r){ return cross(p,q,r); }
  function onSeg(p,q,r){
    return Math.min(p.x,r.x)-1e-9 <= q.x && q.x <= Math.max(p.x,r.x)+1e-9 &&
           Math.min(p.y,r.y)-1e-9 <= q.y && q.y <= Math.max(p.y,r.y)+1e-9 &&
           Math.abs(orient(p,q,r)) < 1e-7;
  }
  const o1=orient(a,b,c), o2=orient(a,b,d), o3=orient(c,d,a), o4=orient(c,d,b);
  if (Math.sign(o1)*Math.sign(o2) < 0 && Math.sign(o3)*Math.sign(o4) < 0) return true;
  if (onSeg(a,c,b) || onSeg(a,d,b) || onSeg(c,a,d) || onSeg(c,b,d)) return true;
  return false;
}

function lineIntersection(a,b,c,d){
  const A1=b.y-a.y, B1=a.x-b.x, C1=A1*a.x+B1*a.y;
  const A2=d.y-c.y, B2=c.x-d.x, C2=A2*c.x+B2*c.y;
  const det=A1*B2-A2*B1;
  if (Math.abs(det)<1e-12) return null;
  return {x:(B2*C1-B1*C2)/det, y:(A1*C2-A2*C1)/det};
}

function regionFromGroup(points){
  const pts = points.slice();
  if (pts.length===1) return {type:'point', pts:[pts[0]]};
  if (pts.length===2) return {type:'segment', pts:[pts[0], pts[1]]};
  const hull = convexHull(pts);
  if (hull.length===1) return {type:'point', pts:[hull[0]]};
  if (hull.length===2) return {type:'segment', pts:[hull[0], hull[1]]};
  return {type:'poly', pts:hull};
}

function candidatePointsForRegions(regions){
  const cand = [];
  for (const r of regions){
    for (const p of r.pts) cand.push(p);
  }
  const edgesOf = (r)=>{
    if (r.type==='point') return [];
    if (r.type==='segment') return [[r.pts[0], r.pts[1]]];
    const e=[];
    for (let i=0;i<r.pts.length;i++){
      e.push([r.pts[i], r.pts[(i+1)%r.pts.length]]);
    }
    return e;
  };
  for (let i=0;i<regions.length;i++){
    for (let j=i+1;j<regions.length;j++){
      const ei=edgesOf(regions[i]), ej=edgesOf(regions[j]);
      for (const [a,b] of ei){
        for (const [c,d] of ej){
          if (!segIntersect(a,b,c,d)) continue;
          const p = lineIntersection(a,b,c,d);
          if (p) cand.push(p);
        }
      }
    }
  }
  return cand;
}

function intersectionNonEmpty(regions){
  const m = regions.length;
  if (m===0) return false;
  if (m===1) return true;

  const triples = [];
  if (m===2) triples.push([0,1]);
  else {
    for (let i=0;i<m;i++) for (let j=i+1;j<m;j++) for (let k=j+1;k<m;k++) triples.push([i,j,k]);
  }

  for (const idxs of triples){
    const regs = idxs.map(t=>regions[t]);
    const cand = candidatePointsForRegions(regs);
    let ok = false;
    for (const p of cand){
      if (regs.every(r=>pointInRegion(p,r))){
        ok = true; break;
      }
    }
    if (!ok){
      let sx=0, sy=0, cnt=0;
      for (const r of regs){ for (const v of r.pts){ sx+=v.x; sy+=v.y; cnt++; } }
      if (cnt>0){
        const p={x:sx/cnt,y:sy/cnt};
        if (regs.every(r=>pointInRegion(p,r))) ok=true;
      }
    }
    if (!ok) return false;
  }
  return true;
}

/* ===================== PARTITIONS (k-partitions of indices) ===================== */

function kPartitionsIndices(n,k){
  if (k<1 || k>n) return [];
  const elems = Array.from({length:n}, (_,i)=>i);

  function rec(remaining, current, partsLeft){
    if (partsLeft===1) return [current.concat([remaining])];
    const out=[];
    const maxSize = remaining.length - partsLeft + 1;
    for (let size=1; size<=maxSize; size++){
      const subs = subsetsOfSize(remaining, size);
      for (const sub of subs){
        const rest = remaining.filter(x=>!sub.includes(x));
        out.push(...rec(rest, current.concat([sub]), partsLeft-1));
      }
    }
    return out;
  }

  const raw = rec(elems, [], k);

  const seen = new Set();
  const out = [];
  for (const p of raw){
    const canon = canonPartition(p);
    const key = JSON.stringify(canon);
    if (!seen.has(key)){
      seen.add(key);
      out.push(canon);
    }
  }
  return out;
}

function subsetsOfSize(arr, size){
  const res=[];
  const n=arr.length;
  function go(start, comb){
    if (comb.length===size){ res.push(comb.slice()); return; }
    for (let i=start;i<n;i++){
      comb.push(arr[i]);
      go(i+1, comb);
      comb.pop();
    }
  }
  go(0,[]);
  return res;
}

function canonPartition(p){
  const blocks = p.map(b=> b.slice().sort((a,b)=>a-b));
  blocks.sort((A,B)=>{
    const m=Math.min(A.length,B.length);
    for (let i=0;i<m;i++) if (A[i]!==B[i]) return A[i]-B[i];
    return A.length-B.length;
  });
  return blocks;
}

/* ===================== MOVE-1 ADJACENCY ===================== */

function movesFromPartition(p){
  const k = p.length;
  const moves = [];
  for (let i=0;i<k;i++){
    if (p[i].length<2) continue;
    for (const x of p[i]){
      for (let j=0;j<k;j++){
        if (j===i) continue;
        const q = p.map(b=>b.slice());
        q[i] = q[i].filter(v=>v!==x);
        q[j] = q[j].concat([x]);
        moves.push(canonPartition(q));
      }
    }
  }
  const seen=new Set(), out=[];
  for (const m of moves){
    const key=JSON.stringify(m);
    if (!seen.has(key)){ seen.add(key); out.push(m); }
  }
  return out;
}

function relatedMove1(p1,p2){
  const key2 = JSON.stringify(canonPartition(p2));
  const mv = movesFromPartition(p1);
  return mv.some(m=>JSON.stringify(m)===key2);
}

function edgesBetweenPartitions(parts){
  const edges=[];
  for (let i=0;i<parts.length;i++){
    for (let j=i+1;j<parts.length;j++){
      if (relatedMove1(parts[i], parts[j])) edges.push([i,j]);
    }
  }
  return edges;
}

/* ===================== DRAWING ===================== */

function worldToCanvas(p, W, H, range){
  const x = (p.x + range) / (2*range) * W;
  const y = (range - p.y) / (2*range) * H;
  return {x,y};
}
function canvasToWorld(p, W, H, range){
  const x = p.x / W * (2*range) - range;
  const y = range - p.y / H * (2*range);
  return {x,y};
}

function drawAxes(ctx,W,H){
  ctx.save();
  ctx.strokeStyle = "#2a2d3a";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(W/2,0); ctx.lineTo(W/2,H);
  ctx.moveTo(0,H/2); ctx.lineTo(W,H/2);
  ctx.stroke();
  ctx.restore();
}

function drawPointsScene(ctx, pts, range){
  const W=ctx.canvas.width, H=ctx.canvas.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "#0b0c10";
  ctx.fillRect(0,0,W,H);
  drawAxes(ctx,W,H);
  ctx.strokeStyle="#2a2d3a"; ctx.strokeRect(0.5,0.5,W-1,H-1);

  for (let i=0;i<pts.length;i++){
    const pc = worldToCanvas(pts[i], W,H,range);
    ctx.beginPath();
    ctx.fillStyle = "#ff4b4b";
    ctx.arc(pc.x, pc.y, 7, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle="#e8e8ea";
    ctx.font="12px system-ui";
    ctx.fillText(String(i+1), pc.x+9, pc.y-9);
  }
}

function drawHullPartition(ctx, pts, partition, range){
  const W=ctx.canvas.width, H=ctx.canvas.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "#0b0c10";
  ctx.fillRect(0,0,W,H);
  drawAxes(ctx,W,H);
  ctx.strokeStyle="#2a2d3a"; ctx.strokeRect(0.5,0.5,W-1,H-1);

  if (!partition){ return; }

  const k = partition.length;
  for (let gi=0; gi<k; gi++){
    const block = partition[gi].map(idx=>pts[idx]);
    const region = regionFromGroup(block);
    const hue = (gi*360)/Math.max(1,k);
    const stroke = `hsl(${hue} 80% 60%)`;
    const fill = `hsla(${hue} 80% 60% / 0.18)`;

    ctx.lineWidth = 2;
    ctx.strokeStyle = stroke;
    ctx.fillStyle = fill;

    if (region.type==='point'){
      const p = worldToCanvas(region.pts[0], W,H,range);
      ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2); ctx.fill(); ctx.stroke();
    } else if (region.type==='segment'){
      const a=worldToCanvas(region.pts[0], W,H,range);
      const b=worldToCanvas(region.pts[1], W,H,range);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      ctx.beginPath(); ctx.arc(a.x,a.y,6,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(b.x,b.y,6,0,Math.PI*2); ctx.fill();
    } else {
      const poly = region.pts.map(p=>worldToCanvas(p,W,H,range));
      ctx.beginPath();
      ctx.moveTo(poly[0].x, poly[0].y);
      for (let i=1;i<poly.length;i++) ctx.lineTo(poly[i].x, poly[i].y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
  }

  for (let i=0;i<pts.length;i++){
    const pc = worldToCanvas(pts[i], W,H,range);
    ctx.beginPath();
    ctx.fillStyle = "#e8e8ea";
    ctx.arc(pc.x, pc.y, 3.5, 0, Math.PI*2);
    ctx.fill();
  }
}

function drawGraph(ctx, nodes, edges){
  const W=ctx.canvas.width, H=ctx.canvas.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#0b0c10"; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle="#2a2d3a"; ctx.strokeRect(0.5,0.5,W-1,H-1);

  ctx.strokeStyle="rgba(200,200,210,.6)";
  ctx.lineWidth=2;
  for (const [i,j] of edges){
    const a=nodes[i], b=nodes[j];
    ctx.beginPath();
    ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
    ctx.stroke();
  }

  for (let i=0;i<nodes.length;i++){
    const n=nodes[i];
    ctx.beginPath();
    ctx.fillStyle="#4da3ff";
    ctx.arc(n.x,n.y,10,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle="#0b0c10";
    ctx.font="12px system-ui";
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText(String(i+1), n.x, n.y);
  }
  ctx.textAlign="start"; ctx.textBaseline="alphabetic";
}

/* ===================== GLOBAL STATE ===================== */

const state = {
  range: 4,
  nPts: 5,
  kParts: 1,
  pts: [],
  partitionsAll: [],
  partitionsInter: [],
  edges: [],
  graphNodes: [],
  selectedInterIndex: 0
};

const elNPts = document.getElementById('nPts');
const elK = document.getElementById('kParts');
const elRange = document.getElementById('range');
const elRangeVal = document.getElementById('rangeVal');
const elSelPart = document.getElementById('selPart');

const pillTotal = document.getElementById('pillTotal');
const pillInter = document.getElementById('pillInter');
const pillEdges = document.getElementById('pillEdges');

const cPts = document.getElementById('canvasPts');
const cHull = document.getElementById('canvasHull');
const cGraph = document.getElementById('canvasGraph');
const ctxPts = cPts.getContext('2d');
const ctxHull = cHull.getContext('2d');
const ctxGraph = cGraph.getContext('2d');

/* ===================== INIT CONTROLS ===================== */

function initControls(){
  for (let n=1;n<=9;n++){
    const o=document.createElement('option');
    o.value=String(n); o.textContent=String(n);
    if (n===state.nPts) o.selected=true;
    elNPts.appendChild(o);
  }
  for (let k=1;k<=5;k++){
    const o=document.createElement('option');
    o.value=String(k); o.textContent=String(k);
    if (k===state.kParts) o.selected=true;
    elK.appendChild(o);
  }
  elRange.value = String(state.range);
  elRangeVal.textContent = String(state.range);
}
initControls();

/* ===================== RANDOM POINTS (unique-ish) ===================== */

function randomPointsUnique(n, range){
  const pts=[];
  const seen=new Set();
  let guard=0;
  while (pts.length<n && guard<5000){
    guard++;
    const x = (Math.random()*2-1)*range;
    const y = (Math.random()*2-1)*range;
    const key = `${x.toFixed(4)},${y.toFixed(4)}`;
    if (!seen.has(key)){
      seen.add(key);
      pts.push({x,y});
    }
  }
  while (pts.length<n) pts.push({x:(Math.random()*2-1)*range, y:(Math.random()*2-1)*range});
  return pts;
}

/* ===================== RECOMPUTE ===================== */

function updatePartitionSelector(){
  elSelPart.innerHTML = "";
  const m = state.partitionsInter.length;
  if (m===0){
    const o=document.createElement('option');
    o.value="0"; o.textContent="(none)";
    elSelPart.appendChild(o);
    state.selectedInterIndex = 0;
    return;
  }
  for (let i=0;i<m;i++){
    const o=document.createElement('option');
    o.value=String(i);
    o.textContent=String(i+1);
    elSelPart.appendChild(o);
  }
  state.selectedInterIndex = clamp(state.selectedInterIndex, 0, m-1);
  elSelPart.value = String(state.selectedInterIndex);
}

function redrawAll(){
  drawPointsScene(ctxPts, state.pts, state.range);
  drawGraph(ctxGraph, state.graphNodes, state.edges);
  const p = state.partitionsInter[state.selectedInterIndex] || null;
  drawHullPartition(ctxHull, state.pts, p, state.range);

  pillTotal.textContent = `Total partitions: ${state.partitionsAll.length}`;
  pillInter.textContent = `With intersection: ${state.partitionsInter.length}`;
  pillEdges.textContent = `Edges (move-1): ${state.edges.length}`;
  
  // Actualizar estadísticas automáticamente
  updateGraphStats();
}

function recomputeAll(){
  state.partitionsAll = kPartitionsIndices(state.nPts, state.kParts);

  const inter = [];
  for (const part of state.partitionsAll){
    const regions = part.map(block => regionFromGroup(block.map(i=>state.pts[i])));
    if (intersectionNonEmpty(regions)) inter.push(part);
  }
  state.partitionsInter = inter;

  state.edges = edgesBetweenPartitions(state.partitionsInter);

  const m = state.partitionsInter.length;
  const W = cGraph.width, H = cGraph.height;
  const cx = W/2, cy = H/2, R = Math.min(W,H)*0.35;
  state.graphNodes = [];
  for (let i=0;i<m;i++){
    const ang = (2*Math.PI*i)/Math.max(1,m) - Math.PI/2;
    state.graphNodes.push({x: cx + R*Math.cos(ang), y: cy + R*Math.sin(ang)});
  }

  updatePartitionSelector();
  redrawAll();
}

/* ===================== UI EVENTS ===================== */

elNPts.addEventListener('change', ()=>{
  state.nPts = parseInt(elNPts.value,10);
  state.pts = randomPointsUnique(state.nPts, state.range);
  state.kParts = clamp(state.kParts, 1, state.nPts);
  elK.value = String(state.kParts);
  recomputeAll();
});

elK.addEventListener('change', ()=>{
  state.kParts = parseInt(elK.value,10);
  state.kParts = clamp(state.kParts, 1, state.nPts);
  elK.value = String(state.kParts);
  recomputeAll();
});

elRange.addEventListener('input', ()=>{
  state.range = parseInt(elRange.value,10);
  elRangeVal.textContent = String(state.range);
  for (const p of state.pts){
    p.x = clamp(p.x, -state.range, state.range);
    p.y = clamp(p.y, -state.range, state.range);
  }
  recomputeAll();
});

elSelPart.addEventListener('change', ()=>{
  state.selectedInterIndex = parseInt(elSelPart.value,10) || 0;
  redrawAll();
});

/* ===================== DRAG: POINTS ===================== */

let draggingPoint = -1;

function getMousePos(canvas, evt){
  const r = canvas.getBoundingClientRect();
  return { x: (evt.clientX - r.left) * (canvas.width / r.width),
           y: (evt.clientY - r.top) * (canvas.height / r.height) };
}

cPts.addEventListener('pointerdown', (e)=>{
  const m = getMousePos(cPts,e);
  const W=cPts.width,H=cPts.height;
  let best=-1, bestD=Infinity;
  for (let i=0;i<state.pts.length;i++){
    const pc = worldToCanvas(state.pts[i], W,H,state.range);
    const d = (pc.x-m.x)*(pc.x-m.x)+(pc.y-m.y)*(pc.y-m.y);
    if (d<bestD){ bestD=d; best=i; }
  }
  if (bestD < 18*18){
    draggingPoint = best;
    cPts.setPointerCapture(e.pointerId);
  }
});

cPts.addEventListener('pointermove', (e)=>{
  if (draggingPoint<0) return;
  const m = getMousePos(cPts,e);
  const w = canvasToWorld(m, cPts.width, cPts.height, state.range);
  state.pts[draggingPoint].x = clamp(w.x, -state.range, state.range);
  state.pts[draggingPoint].y = clamp(w.y, -state.range, state.range);
  recomputeAll();
});

cPts.addEventListener('pointerup', (e)=>{
  draggingPoint=-1;
  try{ cPts.releasePointerCapture(e.pointerId); }catch(_){}
});

/* ===================== DRAG: GRAPH NODES ===================== */

let draggingNode = -1;

cGraph.addEventListener('pointerdown', (e)=>{
  const m = getMousePos(cGraph,e);
  let best=-1, bestD=Infinity;
  for (let i=0;i<state.graphNodes.length;i++){
    const n=state.graphNodes[i];
    const d=(n.x-m.x)*(n.x-m.x)+(n.y-m.y)*(n.y-m.y);
    if (d<bestD){ bestD=d; best=i; }
  }
  if (bestD < 18*18){
    draggingNode = best;
    cGraph.setPointerCapture(e.pointerId);
  }
});

cGraph.addEventListener('pointermove', (e)=>{
  if (draggingNode<0) return;
  const m = getMousePos(cGraph,e);
  state.graphNodes[draggingNode].x = m.x;
  state.graphNodes[draggingNode].y = m.y;
  drawGraph(ctxGraph, state.graphNodes, state.edges);
});

cGraph.addEventListener('pointerup', (e)=>{
  draggingNode=-1;
  try{ cGraph.releasePointerCapture(e.pointerId); }catch(_){}
});

/* ===================== EXPORT: COORDINATES TXT ===================== */

function downloadText(filename, text){
  const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url; a.download=filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

document.getElementById('btnCoords').addEventListener('click', ()=>{
  const parts = state.partitionsInter;
  if (parts.length===0){
    alert("No intersecting partitions to export.");
    return;
  }
  let out="";
  parts.forEach((p,idx)=>{
    out += `Partition ${idx+1}:\n`;
    p.forEach((block,bi)=>{
      const coords = block.map(i=> state.pts[i]).map(pt=>`{${pt.x.toFixed(6)}, ${pt.y.toFixed(6)}}`);
      out += `  Block ${bi+1}: { ${coords.join(", ")} }\n`;
    });
    out += "\n";
  });
  downloadText("partitions-coordinates.txt", out);
});

/* ===================== EXPORT: PDF (4 per page) ===================== */

async function exportPDF4PerPage(){
  const parts = state.partitionsInter;
  if (parts.length===0){
    alert("No intersecting partitions to export.");
    return;
  }

  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({orientation:"portrait", unit:"pt", format:"letter"});
  const pageW = pdf.internal.pageSize.getWidth();
  const pageH = pdf.internal.pageSize.getHeight();

  const margin = 36;
  const gap = 18;
  const cellW = (pageW - 2*margin - gap) / 2;
  const cellH = (pageH - 2*margin - gap) / 2;

  const off = document.createElement('canvas');
  off.width = 520; off.height = 520;
  const offCtx = off.getContext('2d');

  function place(iOnPage){
    const row = Math.floor(iOnPage/2);
    const col = iOnPage%2;
    const x = margin + col*(cellW + gap);
    const y = margin + row*(cellH + gap);
    return {x,y};
  }

  for (let i=0;i<parts.length;i++){
    const iOnPage = i % 4;
    if (i!==0 && iOnPage===0) pdf.addPage();

    drawHullPartition(offCtx, state.pts, parts[i], state.range);

    const label = `Partition ${i+1}`;
    const pos = place(iOnPage);

    pdf.setFont("helvetica","bold");
    pdf.setFontSize(12);
    pdf.text(label, pos.x, pos.y - 6);

    const img = off.toDataURL("image/png");

    const imgW = cellW;
    const imgH = cellH - 18;
    pdf.addImage(img, "PNG", pos.x, pos.y, imgW, imgH, undefined, "FAST");
  }

  pdf.save("partitions-convexhulls.pdf");
}

document.getElementById('btnPDF').addEventListener('click', ()=>{
  exportPDF4PerPage();
});

/* ===================== GRAPH STATISTICS FUNCTIONS ===================== */

function buildAdjacencyList(n, edges) {
  const adj = Array.from({ length: n }, () => []);
  for (const [u, v] of edges) {
    adj[u].push(v);
    adj[v].push(u);
  }
  return adj;
}

function getConnectedComponents(adj) {
  const n = adj.length;
  const visited = new Array(n).fill(false);
  const components = [];
  
  for (let i = 0; i < n; i++) {
    if (!visited[i]) {
      const stack = [i];
      const component = [];
      visited[i] = true;
      
      while (stack.length) {
        const node = stack.pop();
        component.push(node);
        
        for (const neighbor of adj[node]) {
          if (!visited[neighbor]) {
            visited[neighbor] = true;
            stack.push(neighbor);
          }
        }
      }
      
      components.push(component);
    }
  }
  
  return components;
}

function getDegrees(adj) {
  return adj.map(neighbors => neighbors.length);
}

function isConnected(adj) {
  return getConnectedComponents(adj).length === 1;
}

function getDegreeStats(adj) {
  const degrees = getDegrees(adj);
  if (degrees.length === 0) return { min: 0, max: 0, avg: 0 };
  
  const min = Math.min(...degrees);
  const max = Math.max(...degrees);
  const avg = degrees.reduce((a, b) => a + b, 0) / degrees.length;
  
  return { min, max, avg: avg.toFixed(2) };
}

function getCliqueNumber(adj) {
  const n = adj.length;
  if (n === 0) return 0;
  
  // Para grafos pequeños, podemos usar un enfoque simple
  let maxClique = 1;
  
  // Convertir lista de adyacencia a matriz booleana para acceso rápido
  const adjMatrix = Array.from({ length: n }, () => new Array(n).fill(false));
  for (let i = 0; i < n; i++) {
    for (const j of adj[i]) {
      adjMatrix[i][j] = true;
    }
  }
  
  // Buscar cliques de tamaño 2 y 3 (suficiente para grafos pequeños)
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (adjMatrix[i][j]) {
        maxClique = Math.max(maxClique, 2);
        
        // Buscar triángulos
        for (let k = j + 1; k < n; k++) {
          if (adjMatrix[i][k] && adjMatrix[j][k]) {
            maxClique = Math.max(maxClique, 3);
          }
        }
      }
    }
  }
  
  return maxClique;
}

function computeAllGraphStats() {
  const n = state.partitionsInter.length;
  const edges = state.edges;
  
  if (n === 0) {
    return {
      vertices: 0,
      edges: 0,
      components: 0,
      connected: false,
      minDegree: 0,
      maxDegree: 0,
      avgDegree: 0,
      cliqueNumber: 0,
      density: 0
    };
  }
  
  const adj = buildAdjacencyList(n, edges);
  const components = getConnectedComponents(adj);
  const degreeStats = getDegreeStats(adj);
  const cliqueNumber = getCliqueNumber(adj);
  const density = n > 1 ? (edges.length / (n * (n - 1) / 2)).toFixed(3) : 0;
  
  return {
    vertices: n,
    edges: edges.length,
    components: components.length,
    connected: isConnected(adj),
    minDegree: degreeStats.min,
    maxDegree: degreeStats.max,
    avgDegree: degreeStats.avg,
    cliqueNumber: cliqueNumber,
    density: density
  };
}

function updateGraphStats() {
  const stats = computeAllGraphStats();
  
  // Actualizar el grid de estadísticas
  const statsGrid = document.getElementById('statsGrid');
  statsGrid.innerHTML = `
    <div class="stat-item">Vertices<div class="stat-value">${stats.vertices}</div></div>
    <div class="stat-item">Edges<div class="stat-value">${stats.edges}</div></div>
    <div class="stat-item">Components<div class="stat-value">${stats.components}</div></div>
    <div class="stat-item">Connected<div class="stat-value">${stats.connected ? 'Yes' : 'No'}</div></div>
    <div class="stat-item">Min Degree<div class="stat-value">${stats.minDegree}</div></div>
    <div class="stat-item">Max Degree<div class="stat-value">${stats.maxDegree}</div></div>
    <div class="stat-item">Avg Degree<div class="stat-value">${stats.avgDegree}</div></div>
    <div class="stat-item">Clique ω<div class="stat-value">${stats.cliqueNumber}</div></div>
    <div class="stat-item">Density<div class="stat-value">${stats.density}</div></div>
  `;
  
  // Actualizar también el output de texto
  document.getElementById('statsOutput').innerHTML = `
    <b>Graph Statistics Summary:</b><br>
    • <b>${stats.vertices}</b> vertices, <b>${stats.edges}</b> edges<br>
    • <b>${stats.components}</b> connected component(s)<br>
    • Graph is <b>${stats.connected ? 'connected' : 'disconnected'}</b><br>
    • Degree range: <b>${stats.minDegree}</b> to <b>${stats.maxDegree}</b> (avg: ${stats.avgDegree})<br>
    • Clique number ω(G): <b>${stats.cliqueNumber}</b><br>
    • Edge density: <b>${stats.density}</b>
  `;
}

/* ===================== EVENT LISTENERS PARA BOTONES DE ESTADÍSTICAS ===================== */

document.getElementById('btnStatsBasic').addEventListener('click', () => {
  const stats = computeAllGraphStats();
  document.getElementById('statsOutput').innerHTML = `
    <b>Basic Graph Statistics:</b><br>
    • Vertices: <b>${stats.vertices}</b><br>
    • Edges: <b>${stats.edges}</b><br>
    • Connected Components: <b>${stats.components}</b><br>
    • Graph Connectivity: <b>${stats.connected ? 'Connected' : 'Disconnected'}</b><br>
    • Edge Density: <b>${stats.density}</b><br>
    <br>
    <i>Density = 2|E| / (|V|(|V|-1))</i>
  `;
});

document.getElementById('btnStatsDegrees').addEventListener('click', () => {
  const stats = computeAllGraphStats();
  const adj = buildAdjacencyList(stats.vertices, state.edges);
  const degrees = getDegrees(adj);
  
  let degreeDist = '';
  const degreeCount = {};
  degrees.forEach(d => {
    degreeCount[d] = (degreeCount[d] || 0) + 1;
  });
  
  const sortedDegrees = Object.keys(degreeCount).sort((a, b) => a - b);
  sortedDegrees.forEach(d => {
    degreeDist += `• Degree ${d}: ${degreeCount[d]} vertex(es)<br>`;
  });
  
  document.getElementById('statsOutput').innerHTML = `
    <b>Degree Statistics:</b><br>
    • Minimum Degree: <b>δ(G) = ${stats.minDegree}</b><br>
    • Maximum Degree: <b>Δ(G) = ${stats.maxDegree}</b><br>
    • Average Degree: <b>${stats.avgDegree}</b><br>
    <br>
    <b>Degree Distribution:</b><br>
    ${degreeDist}
  `;
});

document.getElementById('btnStatsConnectivity').addEventListener('click', () => {
  const stats = computeAllGraphStats();
  const adj = buildAdjacencyList(stats.vertices, state.edges);
  const components = getConnectedComponents(adj);
  
  let componentsInfo = '';
  components.forEach((comp, idx) => {
    componentsInfo += `• Component ${idx + 1}: ${comp.length} vertex(es)<br>`;
  });
  
  document.getElementById('statsOutput').innerHTML = `
    <b>Connectivity Analysis:</b><br>
    • Number of Components: <b>${stats.components}</b><br>
    • Graph is <b>${stats.connected ? 'connected' : 'disconnected'}</b><br>
    • <b>κ(G)</b> (vertex connectivity): ${stats.connected ? '≥1' : '0'}<br>
    <br>
    <b>Components Details:</b><br>
    ${componentsInfo}
  `;
});

document.getElementById('btnStatsClique').addEventListener('click', () => {
  const stats = computeAllGraphStats();
  
  document.getElementById('statsOutput').innerHTML = `
    <b>Clique Analysis:</b><br>
    • Clique Number <b>ω(G)</b>: <b>${stats.cliqueNumber}</b><br>
    • This is the size of the largest complete subgraph<br>
    <br>
    <b>Interpretation:</b><br>
    • ω(G) = 1: No edges (independent set)<br>
    • ω(G) = 2: Contains edges but no triangles<br>
    • ω(G) ≥ 3: Contains triangles or larger cliques<br>
    <br>
    <i>For this graph: ω(G) = ${stats.cliqueNumber}</i>
  `;
});

/* ===================== STARTUP ===================== */

function bootstrap(){
  state.pts = randomPointsUnique(state.nPts, state.range);
  recomputeAll();
  
  // Inicializar estadísticas
  updateGraphStats();
}
bootstrap();
</script>
</body>
</html>
